1: Number of frames = 4000
---- RESULTS ----
Elapsed execution time: 107.164359s
1262 Line-Wall Collisions
19806 Line-Line Collisions
---- END RESULTS ----

2. This is not a problem for the quad tree. This line will exist at the top level of the quad tree, and can be passed into each of the leaves when detecting collisions in those leaves. This will still effectively speed up the collision detection.

3. Number of frames = 4000
---- RESULTS ----
Elapsed execution time: 25.596644s
1262 Line-Wall Collisions
19806 Line-Line Collisions
---- END RESULTS ----

4. We got a >4x speed-up, which is larger than we expected.

5. We built a quadtree which only stores lines in its leaves. We also considered the lines 
as parallelograms when placing them into quadtree nodes. To detect the collisions, we 
recursively called our detect collisions function on each of the
four quadrants in the quadtree, until we hit leaves. Then we iterated through all of the leaves
in that leaf using the same O(N^2) collision test.

To accomodate for lines which spanned multiple nodes after a quadtree was divided, we placed that
line in each of the nodes in which it intersected. To avoid repeated collisions being marked,
we checked to make sure the intersection was not part of the event list before adding the 
intersection.

6. We tested N = 80, 100, 120, 140, and 160, and found that N=140 gave us the best performance 
for 4000 frames. We concluded this was due the to overhead of recursing too deeply to divide the
collisions up, which was not worth the small decrease in the O(N^2) base case.

7. Our first optimization was to try rewriting a method for calculating when two lines intersect. We attempted to implement an algorithm that would check if each endpoint of one line was on either side of the other line. However, when addressing edge cases such as when one line's endpoint was on the other line, we ran into errors with floating point number rounding. On these edgecases, the best alternative was to resort to the original intersection detection algorithm, and the overall result was a slower runtime. As a result, we did not continue to use this updated line intersection detection function.

We also tried precomputing the length of each line. This did not result in a significant speedup.

We then made the Quadtree a parameter of the CollisionWorld. This allowed us to update the 
Quadtree at each timestep rather than recreating it, and this led to a 5% speedup.

We also added a preliminary check to our function that checks if we need to include a line in the quadtree.
This check sees if all of the points of the parallelogram form by the line are off to any side of the box
to quickly exclude it. This reduces the number of times we need to calculate pointInParallelogram and
intersectLines, and led to a 30% speedup.

Next, we tried inlining all of the functions. We found that inlining the non recursive IntersectionDetection, Quadtree, and Vec file functions led to a speedup, but not inlining the CollisionWorld and EventList functions.

We decreased the number of function calls in our check of whether or not a parallelogram that represents a moving line intersects a box represented by a leaf in the quadtree. We only have 16 function calls--eight to determine whether one corner of one shape lies within another shap, and eight to determine whether the lines of the quadtree square intersects any part of the parallelogram that represents the moving line.

Also, we created a new method that returns whether or not an intersection exists before checking what type of intersection exists. We called this method fastIntersect, and it resulted in several seconds speedup.

Finally, we reordered function calls in the intersect method and rewrote part of the method to allow for more efficient checking of the intersect type. 

8.
  %   cumulative   self              self     total
 time   seconds   seconds    calls  ms/call  ms/call  name
 25.00      0.80     0.80 46415185     0.00     0.00  fastIntersect
 21.57      1.49     0.69 143021580     0.00     0.00  Vec_multiply
 20.32      2.14     0.65 143020897     0.00     0.00  Vec_add
 10.63      2.48     0.34     1001     0.34     2.18  detectCollisions
  6.88      2.70     0.22    13565     0.02     0.03  shouldDivideTree
  5.31      2.87     0.17 46418439     0.00     0.00  Vec_subtract

