1: Number of frames = 4000
---- RESULTS ----
Elapsed execution time: 107.164359s
1262 Line-Wall Collisions
19806 Line-Line Collisions
---- END RESULTS ----

2. This is not a problem for the quad tree. This line will exist at the top level of the quad tree, and can be passed into each of the leaves when detecting collisions in those leaves. This will still effectively speed up the collision detection.

3. Number of frames = 4000
---- RESULTS ----
Elapsed execution time: 25.596644s
1262 Line-Wall Collisions
19806 Line-Line Collisions
---- END RESULTS ----

4. We got a >4x speed-up, which is larger than we expected.

5. We built a quadtree which only stores lines in its leaves. We also considered the lines 
as parallelograms when placing them into quadtree nodes. To detect the collisions, we 
recursively called our detect collisions function on each of the
four quadrants in the quadtree, until we hit leaves. Then we iterated through all of the leaves
in that leaf using the same O(N^2) collision test.

To accomodate for lines which spanned multiple nodes after a quadtree was divided, we placed that
line in each of the nodes in which it intersected. To avoid repeated collisions being marked,
we checked to make sure the intersection was not part of the event list before adding the 
intersection.

6. We tested N = 80, 100, 120, 140, and 160, and found that N=140 gave us the best performance 
for 4000 frames. We concluded this was due the to overhead of recursing too deeply to divide the
collisions up, which was not worth the small decrease in the O(N^2) base case.

7. Our first optimization was to try rewriting a method for calculating when a line intersects a
polygon. Results:...

We also tried precomputing the length of each line. This did not result in a significant speedup.

We then made the Quadtree a parameter of the CollisionWorld. This allowed us to update the 
Quadtree at each timestep rather than recreating it, and this led to a 5% speedup.

We also added a preliminary check to our function that checks if we need to include a line in the quadtree.
This check sees if all of the points of the parallelogram form by the line are off to any side of the box
to quickly exclude it. This reduces the number of times we need to calculate pointInParallelogram and
intersectLines, and led to a 30% speedup.

8.
  %   cumulative   self              self     total
 time   seconds   seconds    calls  ms/call  ms/call  name
 25.00      0.80     0.80 46415185     0.00     0.00  fastIntersect
 21.57      1.49     0.69 143021580     0.00     0.00  Vec_multiply
 20.32      2.14     0.65 143020897     0.00     0.00  Vec_add
 10.63      2.48     0.34     1001     0.34     2.18  detectCollisions
  6.88      2.70     0.22    13565     0.02     0.03  shouldDivideTree
  5.31      2.87     0.17 46418439     0.00     0.00  Vec_subtract

